ENT.Type 			= "anim"
ENT.Base 			= "sb_base_rd"
ENT.Category 		= "FMP GameMode"

ENT.Spawnable 		= false
ENT.AdminSpawnable	= false


local posSensibility = 40
local angleSensibility = 15
local moveSpeed = 0.4


function ENT:Initialize(child)
	self.BaseClass:Initialize(child)
	child.slots = {}
	child.toGrabTable = {}
	child.toReleaseTable = {}
	if SERVER then
		self.ServerSideInit(child)
	end
end

function ENT:OnBeginMoving(slot) -- Override theses functions to provide clientside or serverside effects!
	
end

function ENT:OnMoving(slot)

end

function ENT:OnReleased(slot)

end

function ENT:OnHold(slot)

end

function ENT:GetSlots()
	--[[
		return table of slots.
		A slot is defined by:
		{
			-- static values
			size,							(number)    = The size of the slot, required
			grabPos,    					(vector)	= The relative position where the entity should be grabbed, required
			normal,							(vector) 	= The normal vector of the slot, required
			blacklist						(table)		= Blacklisted class names, optional
			
			-- internal values, do not modify
			holdableObject,					 	
			holdableObjectNoCollide,		
			holdableObjectWeld,				
			holdableObjectDeltaRoll,
			moving,
			progress
		}
	
	
	]]
	return self.slots
end

function ENT:IsAccepted(slot, eOther)
	for _,class in pairs(slot.blacklist or {}) do
		if class == eOther.ClassName then
			return false
		end
	end
	return true
end

function ENT:GetTotalInputRates()
	
end

function ENT:GetTotalOutputRates()

end

function ENT:GetTotalRessources()

end

function ENT:GetSlotByPos(vRelativePos)
	for _,slot in pairs(self:GetSlots()) do
		if slot:GetPos():Distance(vRelativePos) <= posSensibility then
			return slot
		end
	end
	return nil
end

function ENT:GetSlotLength(slot)
	if slot:GetSize() == 1 then
		return 39
	elseif slot:GetSize() == 2 then
		return -1
	elseif slot:GetSize() == 3 then
		return 151.23
	else
		return -1
	end
end


function ENT:PhysicsCollide(colData, collider)
	local entity = colData.HitEntity
	if entity and entity:IsValid() then
		if entity.GetSlotSize then -- The entity has a method GetSlotSize so it is an holdable entity
			local slot = self:GetSlotByPos(self:WorldToLocal(colData.HitPos))
			if slot and not slot:IsBusy() and not slot:GetPluggedSlot() and entity:GetSlotSize() == slot:GetSize() and not slot:IsBusy() and self:IsAccepted(slot, entity) then
				local prise = entity:LocalToWorld(entity:OBBCenter() - Vector(0, 0, 1)*(entity:OBBMaxs() - entity:OBBMins()).z/2)
				local top = entity:LocalToWorld(entity:OBBCenter() + Vector(0, 0, 1)*(entity:OBBMaxs() - entity:OBBMins()).z/2)
				local ang = Util.AngleBetweenVectors(-slot:GetNormal(), (self:WorldToLocal(prise)-self:WorldToLocal(top)):GetNormalized())
				print(ang)
				if ang < angleSensibility then
					entity:GetPhysicsObject():EnableMotion(false)
					slot.progress = 0
					table.insert(self.toGrabTable, { slot, entity })
					sound.Play("weapons/sentry_upgrading_steam" .. math.floor(math.random()*4.99)+1 .. ".wav", prise)
				end
			end
		end
	end
end

function ENT:Think()
	local needSpeed = false
	--[[for _,slot in pairs(self:GetSlots()) do --checking for null entities...
		if slot and slot:IsPlugged() and not slot:GetPluggedSlot():GetEntity():IsValid() then
			slot:Plug(nil)
			slot:SetNoCollide(nil)
			slot:SetWeld(nil)
		end
	end]]
	for i,toGrab in ipairs(self.toGrabTable) do
		if self:GrabHoldableObject(toGrab[1], toGrab[2], 1) then
			table.remove(self.toGrabTable, i)
			sound.Play("weapons/sentry_upgrading_steam" .. math.floor(math.random()*4.99)+1 .. ".wav", self:LocalToWorld(toGrab[1]:GetPos()))
		else needSpeed = true
		end
	end
	for i,toRelease in ipairs(self.toReleaseTable) do
		if self:ExtractHoldableObject(toRelease[1], toRelease[2], -1) then
			table.remove(self.toReleaseTable, i)
			sound.Play("weapons/sentry_upgrading_steam" .. math.floor(math.random()*4.99)+1 .. ".wav", self:LocalToWorld(toRelease[1]:GetPos()))
		else needSpeed = true
		end
	end
	if needSpeed then
		self:NextThink(CurTime())
		return true
	end
end

function ENT:ExtractHoldableObject(slot, eHoldableObject, nSens)
	if not eHoldableObject or not eHoldableObject:IsValid() then
		slot:SetWorking(false)
		slot:Plug(nil)
		slot.progress = 0
		return true 
	end
	if slot.progress == 0 then
		slot:SetWorking(true)
		if slot:GetWeld() != nil and slot:GetWeld():IsValid() then
			slot:GetWeld():Remove()
		end
	end
	eHoldableObject:GetPhysicsObject():EnableMotion(false)
	eHoldableObject:SetAngles(self:LocalToWorldAngles(slot:GetNormal():Angle() + eHoldableObject:GetHoldAngle()))
	local vec = slot:GetNormal()
	local offset = (eHoldableObject:WorldToLocal(eHoldableObject:GetPos()) - (eHoldableObject:OBBCenter() - Vector(0, 0, 0.5)*(eHoldableObject:OBBMaxs() - eHoldableObject:OBBMins()))).z
	slot.progress = slot.progress + (self:GetSlotLength(slot)/39)*moveSpeed/slot:GetSize()
	eHoldableObject:SetPos(self:LocalToWorld(slot:GetPos()-slot:GetNormal()*self:GetSlotLength(slot)+slot:GetNormal()*offset - nSens*vec*slot.progress))
	if slot.progress >= self:GetSlotLength(slot)*1.1 then
		local holderPhysObject = self:GetPhysicsObject()
		local holdablePhysObject = eHoldableObject:GetPhysicsObject()
		slot.progress = 0
		slot:SetWorking(false)
		holdablePhysObject:SetMass(eHoldableObject.originalMass)
		eHoldableObject:GetPhysicsObject():EnableCollisions(true)
		return true
	end
	return false
end


function ENT:GrabHoldableObject(slot, eHoldableObject, nSens)
	if not eHoldableObject or not eHoldableObject:IsValid() then
		self:SetWorking(false)
		slot:Plug(nil)
		slot.progress = 0
		return true 
	end
	if slot.progress == 0 then
		eHoldableObject:GetPhysicsObject():EnableCollisions(false)
	end
	eHoldableObject:SetAngles(self:LocalToWorldAngles(slot:GetNormal():Angle() + eHoldableObject:GetHoldAngle()))
	local vec = slot:GetNormal()
	local offset = (eHoldableObject:WorldToLocal(eHoldableObject:GetPos()) - (eHoldableObject:OBBCenter() - Vector(0, 0, 0.5)*(eHoldableObject:OBBMaxs() - eHoldableObject:OBBMins()))).z
	slot.progress = slot.progress + (self:GetSlotLength(slot)/39)*moveSpeed/slot:GetSize()
	eHoldableObject:SetPos(self:LocalToWorld(slot:GetPos()+slot:GetNormal()*offset - nSens*vec*slot.progress))
	if slot.progress >= self:GetSlotLength(slot) then
		local holderPhysObject = self:GetPhysicsObject()
		local holdablePhysObject = eHoldableObject:GetPhysicsObject()
		slot.progress = 0
		slot:SetWorking(false)
		slot:Plug(eHoldableObject:GetSlot())
		holdablePhysObject:SetMass(1)
		eHoldableObject.originalMass = holdablePhysObject:GetMass()
		slot:SetWeld(constraint.Weld(self, eHoldableObject, 0, 0, 0, true))
		return true
	end
	return false
end
